<!DOCTYPE html>
<html>
<head>
    <title>Graph Editor</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        #canvas-container {
            flex: 1;
            min-width: 300px;
            height: 600px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .controls {
            flex: 0 0 320px;
            padding: 20px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            height: fit-content;
            max-height: 800px;
            overflow-y: auto;
        }

        @media (max-width: 800px) {
            .main-container { flex-direction: column; }
            .controls { flex: 1; width: auto; }
            #canvas-container { height: 400px; }
        }

        .section {
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: #fff;
        }

        h3 { margin-top: 0; font-size: 1.1em; color: #444; border-bottom: 2px solid #f0f0f0; padding-bottom: 5px;}

        button {
            padding: 8px 12px;
            margin: 4px 2px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            font-weight: 500;
        }

        button:hover { background-color: #45a049; transform: translateY(-1px); }
        button:disabled { background-color: #e0e0e0; color: #999; cursor: not-allowed; transform: none; }

        button.secondary { background-color: #2196F3; }
        button.secondary:hover { background-color: #1976D2; }
        button.warning { background-color: #FF9800; }
        button.warning:hover { background-color: #F57C00; }
        button.danger { background-color: #f44336; }
        button.danger:hover { background-color: #d32f2f; }
        
        .delete-mode { 
            background-color: #d32f2f !important; 
            color: white;
            border: 2px solid #b71c1c;
        }

        input[type="number"] {
            padding: 6px;
            margin: 4px;
            width: 50px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .edge-inputs { display: flex; align-items: center; gap: 5px; }

        #matrix-area {
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #ccc;
            overflow-x: auto;
        }

        table.matrix {
            border-collapse: collapse;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
        }
        table.matrix th, table.matrix td {
            border: 1px solid #ddd;
            width: 30px;
            height: 30px;
            text-align: center;
            padding: 0;
        }
        table.matrix th { background-color: #f1f1f1; font-weight: bold; }
        table.matrix td.active { background-color: #e8f5e9; color: #2e7d32; font-weight: bold; }
        .matrix-info { color: #666; font-style: italic; font-size: 0.9em; }
    </style>
</head>
<body>

    <div class="main-container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <div class="section">
                <h3>Settings</h3>
                <button id="toggleEdgeDirection" class="secondary">Edges: Directed</button>
                <button id="toggleIndex" class="secondary">Index Start: 0</button>
            </div>

            <div class="section">
                <h3>History</h3>
                <button id="undoBtn" class="warning" disabled>Undo</button>
                <button id="redoBtn" class="warning" disabled>Redo</button>
            </div>
            
            <div class="section">
                <h3>Node Operations</h3>
                <button id="addNode">Add Node</button>
            </div>
            
            <div class="section">
                <h3>Edge Operations</h3>
                <div class="edge-inputs">
                    <input type="number" id="source" placeholder="Src" min="0">
                    <span>→</span>
                    <input type="number" id="target" placeholder="Tgt" min="0">
                    <button id="addEdge">Add</button>
                </div>
                <p style="margin:5px 0;font-size:0.8em;color:#666">Click node (orange) then target.</p>
            </div>
            
            <div class="section">
                <h3>Graph Operations</h3>
                <button id="clearAll" class="danger">Clear All</button>
                <button id="deleteMode" class="danger">Delete Mode: OFF</button>
            </div>

            <div class="section">
                <h3>File Operations</h3>
                <button id="downloadPNG">Save PNG</button>
                <button id="exportJSON">Export JSON</button>
                <button id="importBtn" onclick="document.getElementById('fileInput').click()">Import JSON</button>
                <input type="file" id="fileInput" style="display: none" accept=".json">
            </div>
        </div>
    </div>

    <div id="matrix-area">
        <h3>Adjacency Matrix (Max 20x20)</h3>
        <div id="matrix-container">Add nodes to see the matrix.</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const NODE_RADIUS = 20;
        const DRAG_THRESHOLD = 5;
        let nodes = [];
        let edges = [];
        let indexStart = 0;
        let deleteMode = false;
        let edgeDirection = 'directed';
        let selectedNode = null;
        
        let draggedNode = null;
        let dragStartPos = { x: 0, y: 0 };
        let isDragging = false;


        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;

        setupEventListeners();
        resizeCanvas(); 
        recordState();
        draw();

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp); 
            
            document.getElementById('toggleEdgeDirection').addEventListener('click', () => {
                toggleEdgeDirection();
                recordState(); 
            });
            document.getElementById('toggleIndex').addEventListener('click', () => {
                toggleIndex();
                recordState();
            });

            document.getElementById('addNode').addEventListener('click', () => {
                addNodeProgrammatically();
                recordState();
            });
            document.getElementById('addEdge').addEventListener('click', () => {
                const added = addEdgeProgrammatically();
                if(added) recordState();
            });
            document.getElementById('clearAll').addEventListener('click', () => {
                if(nodes.length > 0) {
                    clearAll();
                    recordState();
                }
            });
            document.getElementById('deleteMode').addEventListener('click', toggleDeleteMode);
            
            document.getElementById('downloadPNG').addEventListener('click', downloadPNG);
            document.getElementById('exportJSON').addEventListener('click', exportJSON);
            document.getElementById('fileInput').addEventListener('change', importJSON);
            
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
        }

        function recordState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            const currentState = {
                nodes: JSON.parse(JSON.stringify(nodes)),
                edges: JSON.parse(JSON.stringify(edges)),
                edgeDirection: edgeDirection,
                indexStart: indexStart
            };

            history.push(currentState);
            
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--; 
                loadState(history[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        function loadState(state) {
            nodes = JSON.parse(JSON.stringify(state.nodes));
            edges = JSON.parse(JSON.stringify(state.edges));
            edgeDirection = state.edgeDirection;
            indexStart = state.indexStart;
            
            const dirBtn = document.getElementById('toggleEdgeDirection');
            dirBtn.textContent = `Edges: ${edgeDirection.charAt(0).toUpperCase() + edgeDirection.slice(1)}`;
            dirBtn.className = edgeDirection === 'directed' ? 'secondary' : '';
            
            document.getElementById('toggleIndex').textContent = `Index Start: ${indexStart}`;
            
            selectedNode = null;
            updateInputPlaceholders();
            updateHistoryButtons();
            draw();
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }


        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            draw();
        }

        function getCanvasMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function handleMouseDown(e) {
            const pos = getCanvasMousePos(e);
            const clickedNode = getNodeAtPosition(pos.x, pos.y);
            
            if (deleteMode) {
                if (clickedNode || getEdgeAtPosition(pos.x, pos.y) > -1) {
                    deleteElement(pos.x, pos.y);
                    recordState();
                }
                return;
            }

            if (clickedNode) {
                draggedNode = clickedNode;
                dragStartPos = { x: pos.x, y: pos.y };
                isDragging = false;
            } else {
                addNodeAtPosition(pos.x, pos.y);
                selectedNode = null;
                recordState();
            }
            draw();
        }

        function handleMouseMove(e) {
            const pos = getCanvasMousePos(e);
            const hoverNode = getNodeAtPosition(pos.x, pos.y);
            canvas.style.cursor = hoverNode ? 'pointer' : 'crosshair';

            if (!draggedNode) return;
            
            const dx = pos.x - dragStartPos.x;
            const dy = pos.y - dragStartPos.y;
            
            if (!isDragging && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {
                isDragging = true;
                selectedNode = null; 
            }

            if (isDragging) {
                canvas.style.cursor = 'grabbing';
                draggedNode.x = clamp(pos.x, NODE_RADIUS, canvas.width - NODE_RADIUS);
                draggedNode.y = clamp(pos.y, NODE_RADIUS, canvas.height - NODE_RADIUS);
                draw();
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                recordState();
                isDragging = false;
                draggedNode = null;
                canvas.style.cursor = 'crosshair';
            } else if (draggedNode) {
                handleNodeClick(draggedNode);
                draggedNode = null;
            }
            draw();
        }

        function handleNodeClick(clickedNode) {
            if (selectedNode === clickedNode) {
                selectedNode = null;
            } else if (selectedNode) {
                const created = createEdge(selectedNode, clickedNode);
                if (created) recordState();
                selectedNode = null;
            } else {
                selectedNode = clickedNode;
            }
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        function createEdge(sourceNode, targetNode) {
            if (sourceNode.id === targetNode.id) {
                alert("Cannot link node to itself.");
                return false;
            }
            const exists = edges.some(e => 
                (e.source === sourceNode.id && e.target === targetNode.id) ||
                (edgeDirection !== 'directed' && e.source === targetNode.id && e.target === sourceNode.id)
            );
            if (!exists) {
                edges.push({ source: sourceNode.id, target: targetNode.id });
                return true;
            } else {
                alert("Edge already exists.");
                return false;
            }
        }

        function addNodeProgrammatically() {
            const margin = 40;
            const spacing = 70;
            const cols = Math.floor((canvas.width - margin * 2) / spacing);
            const row = Math.floor(nodes.length / cols);
            const col = nodes.length % cols;
            addNodeAtPosition(margin + col * spacing, margin + row * spacing);
        }

        function getNextAvailableId() {
            const usedIds = new Set(nodes.map(n => n.id));
            let id = 0;
            while (usedIds.has(id)) id++;
            return id;
        }

        function addNodeAtPosition(x, y) {
            const clampedX = clamp(x, NODE_RADIUS, canvas.width - NODE_RADIUS);
            const clampedY = clamp(y, NODE_RADIUS, canvas.height - NODE_RADIUS);
            nodes.push({ id: getNextAvailableId(), x: clampedX, y: clampedY });
        }

        function addEdgeProgrammatically() {
            const sVal = parseInt(document.getElementById('source').value);
            const tVal = parseInt(document.getElementById('target').value);
            const s = sVal - indexStart;
            const t = tVal - indexStart;

            if (isValidEdge(s, t)) {
                edges.push({ source: s, target: t });
                document.getElementById('source').value = '';
                document.getElementById('target').value = '';
                draw();
                return true;
            }
            return false;
        }

        function isValidEdge(source, target) {
            if (isNaN(source) || isNaN(target)) return false;
            if (source === target) { alert("Source = Target"); return false; }
            const sNode = nodes.find(n => n.id === source);
            const tNode = nodes.find(n => n.id === target);
            if (!sNode || !tNode) { alert("Invalid Node IDs"); return false; }
            const exists = edges.some(e => 
                (e.source === source && e.target === target) ||
                (edgeDirection !== 'directed' && e.source === target && e.target === source)
            );
            if (exists) { alert("Edge exists"); return false; }
            return true;
        }

        function clearAll() {
            nodes = [];
            edges = [];
            selectedNode = null;
            draw();
        }

        function toggleDeleteMode() {
            deleteMode = !deleteMode;
            const btn = document.getElementById('deleteMode');
            btn.textContent = `Delete Mode: ${deleteMode ? 'ON' : 'OFF'}`;
            btn.className = deleteMode ? 'delete-mode danger' : 'danger';
            selectedNode = null;
            draw();
        }

        function deleteElement(x, y) {
            const nodeIndex = nodes.findIndex(n => Math.hypot(n.x - x, n.y - y) < NODE_RADIUS);
            if (nodeIndex > -1) {
                const id = nodes[nodeIndex].id;
                nodes.splice(nodeIndex, 1);
                edges = edges.filter(e => e.source !== id && e.target !== id);
                if (selectedNode?.id === id) selectedNode = null;
                draw();
                return;
            }
            const edgeIndex = getEdgeAtPosition(x, y);
            if (edgeIndex > -1) {
                edges.splice(edgeIndex, 1);
                draw();
            }
        }

        function getEdgeAtPosition(x, y) {
            for (let i = edges.length - 1; i >= 0; i--) {
                const e = edges[i];
                const n1 = nodes.find(n => n.id === e.source);
                const n2 = nodes.find(n => n.id === e.target);
                if (n1 && n2 && isPointOnLine(x, y, n1, n2)) {
                    return i;
                }
            }
            return -1;
        }

        function isPointOnLine(x, y, p1, p2) {
            const d1 = Math.hypot(x - p1.x, y - p1.y);
            const d2 = Math.hypot(x - p2.x, y - p2.y);
            const lineLen = Math.hypot(p1.x - p2.x, p1.y - p2.y);
            return Math.abs(d1 + d2 - lineLen) < 3; 
        }

        function getNodeAtPosition(x, y) {
            return nodes.find(n => Math.hypot(n.x - x, n.y - y) < NODE_RADIUS);
        }

        function toggleEdgeDirection() {
            edgeDirection = edgeDirection === 'directed' ? 'undirected' : 'directed';
            const btn = document.getElementById('toggleEdgeDirection');
            btn.textContent = `Edges: ${edgeDirection.charAt(0).toUpperCase() + edgeDirection.slice(1)}`;
            btn.className = edgeDirection === 'directed' ? 'secondary' : '';
            draw();
        }

        function toggleIndex() {
            indexStart = indexStart === 0 ? 1 : 0;
            document.getElementById('toggleIndex').textContent = `Index Start: ${indexStart}`;
            updateInputPlaceholders();
            draw();
        }

        function updateInputPlaceholders() {
            document.getElementById('source').placeholder = `Src (${indexStart}+)`;
            document.getElementById('target').placeholder = `Tgt (${indexStart}+)`;
        }

        function updateAdjacencyMatrix() {
            const container = document.getElementById('matrix-container');
            if (nodes.length === 0) {
                container.innerHTML = '<p style="color:#666">Graph is empty.</p>';
                return;
            }
            const sortedNodes = [...nodes].sort((a, b) => a.id - b.id);
            const limit = 20;
            const displayNodes = sortedNodes.slice(0, limit);
            
            let html = '<table class="matrix">';
            html += '<tr><th></th>';
            displayNodes.forEach(node => { html += `<th>${node.id + indexStart}</th>`; });
            html += '</tr>';

            displayNodes.forEach(sourceNode => {
                html += `<tr><th>${sourceNode.id + indexStart}</th>`;
                displayNodes.forEach(targetNode => {
                    let hasEdge = edges.some(e => 
                        (e.source === sourceNode.id && e.target === targetNode.id) ||
                        (edgeDirection === 'undirected' && e.source === targetNode.id && e.target === sourceNode.id)
                    );
                    html += `<td class="${hasEdge ? 'active' : ''}">${hasEdge ? 1 : 0}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';
            if (nodes.length > limit) {
                html += `<p class="matrix-info">⚠️ Matrix truncated (Max 20 nodes shown).</p>`;
            }
            container.innerHTML = html;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            edges.forEach(edge => {
                const n1 = nodes.find(n => n.id === edge.source);
                const n2 = nodes.find(n => n.id === edge.target);
                if (n1 && n2) drawEdge(n1, n2);
            });
            
            nodes.forEach(drawNode);

            if (selectedNode) {
                ctx.beginPath();
                ctx.arc(selectedNode.x, selectedNode.y, NODE_RADIUS + 4, 0, Math.PI * 2);
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            updateAdjacencyMatrix();
        }

        function drawNode(node) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#2196F3';
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id + indexStart, node.x, node.y);
        }

        function drawEdge(source, target) {
            const dx = target.x - source.x;
            const dy = target.y - source.y;
            const len = Math.hypot(dx, dy);
            if (len === 0) return;

            const uDx = dx / len;
            const uDy = dy / len;

            const startX = source.x + uDx * NODE_RADIUS;
            const startY = source.y + uDy * NODE_RADIUS;
            const endX = target.x - uDx * NODE_RADIUS;
            const endY = target.y - uDy * NODE_RADIUS;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (edgeDirection === 'directed') {
                const arrowSize = 10;
                const angle = Math.atan2(dy, dx);
                ctx.save();
                ctx.translate(endX, endY);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-arrowSize * 1.2, -arrowSize * 0.5);
                ctx.lineTo(-arrowSize * 1.2, arrowSize * 0.5);
                ctx.closePath();
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                ctx.restore();
            }
        }

        function exportJSON() {
            const data = { nodes, edges, settings: { edgeDirection, indexStart } };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
            const a = document.createElement('a');
            a.href = dataStr;
            a.download = 'graph_data.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.nodes && data.edges) {
                        nodes = data.nodes;
                        edges = data.edges;
                        if (data.settings) {
                            edgeDirection = data.settings.edgeDirection || 'directed';
                            indexStart = data.settings.indexStart !== undefined ? data.settings.indexStart : 0;
                        }
                        recordState();
                        loadState({nodes, edges, edgeDirection, indexStart});
                        alert("Import successful.");
                    }
                } catch(err) { alert("Error parsing file."); }
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function downloadPNG() {
            const tCanvas = document.createElement('canvas');
            tCanvas.width = canvas.width;
            tCanvas.height = canvas.height;
            const tCtx = tCanvas.getContext('2d');
            tCtx.fillStyle = 'white';
            tCtx.fillRect(0, 0, tCanvas.width, tCanvas.height);
            tCtx.drawImage(canvas, 0, 0);
            
            const link = document.createElement('a');
            link.download = 'graph.png';
            link.href = tCanvas.toDataURL();
            link.click();
        }
    </script>
</body>
</html>